    elif selection_predictor_method == 'correlation':
        # Matrix which will contain the correlation of each edge to behavior, and the corresponding
        # p values
        R_mat = np.zeros(patients_train_set.shape[1])
        P_mat = np.zeros(patients_train_set.shape[1])
        # Positive and negative mask initialisation
        negative_edges_mask = np.zeros(patients_train_set.shape[1])
        positive_edges_mask = np.zeros(patients_train_set.shape[1])

        for i in range(patients_train_set.shape[1]):
            # Simple correlation between each edges and behavior
            R_mat[i], P_mat[i] = stats.pearsonr(x=patients_train_set[:, i],
                                                y=training_set_behavioral_score)

        # Positive and Negative correlation indices, under the selection threshold
        negative_edges_indices = np.nonzero((R_mat < 0) & (P_mat < significance_selection_threshold))
        positives_edges_indices = np.nonzero((R_mat > 0) & (P_mat < significance_selection_threshold))

        # Fill the corresponding indices with 1 if indices exist, zero elsewhere
        negative_edges_mask[negative_edges_indices] = 1
        positive_edges_mask[positives_edges_indices] = 1

        # Get the sum off all edges in the mask
        negative_edges_summary_values = np.zeros(patients_train_set.shape[0])
        positive_edges_summary_values = np.zeros(patients_train_set.shape[0])

        for i in range(patients_train_set.shape[0]):
            negative_edges_summary_values[i] = np.sum(np.multiply(negative_edges_mask, patients_train_set[i, ...]))
            positive_edges_summary_values[i] = np.sum(np.multiply(positive_edges_mask, patients_train_set[i, ...]))

    elif selection_predictor_method == 'partial correlation':
        # Matrix which will contain the correlation of each edge to behavior, and the corresponding
        # p values
        R_mat = np.zeros(patients_train_set.shape[1])
        P_mat = np.zeros(patients_train_set.shape[1])

        # Positive and negative mask initialisation
        negative_edges_mask = np.zeros(patients_train_set.shape[1])
        positive_edges_mask = np.zeros(patients_train_set.shape[1])

        # Construct temporary array to contain the connectivity, behavior and
        # other variable to regress
        for i in range(patients_train_set.shape[1]):
            R_, P_ = partial_corr(np.c_[patients_train_set[:, i], training_set_behavioral_score,
                                  training_set_confounding_variables])
            R_mat[i] = R_[0, 1]
            P_mat[i] = P_[0, 1]

        # Positive and Negative correlation indices, under the selection threshold
        negative_edges_indices = np.nonzero((R_mat < 0) & (P_mat < significance_selection_threshold))
        positives_edges_indices = np.nonzero((R_mat > 0) & (P_mat < significance_selection_threshold))

        # Fill the corresponding indices with 1 if indices exist, zero elsewhere
        negative_edges_mask[negative_edges_indices] = 1
        positive_edges_mask[positives_edges_indices] = 1

        # Get the sum off all edges in the mask
        negative_edges_summary_values = np.zeros(patients_train_set.shape[0])
        positive_edges_summary_values = np.zeros(patients_train_set.shape[0])

        for i in range(patients_train_set.shape[0]):
            negative_edges_summary_values[i] = np.sum(np.multiply(negative_edges_mask, patients_train_set[i, ...]))
            positive_edges_summary_values[i] = np.sum(np.multiply(positive_edges_mask, patients_train_set[i, ...]))